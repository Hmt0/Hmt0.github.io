<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/project/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/project/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/project/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/project/images/logo.svg" color="#222">

<link rel="stylesheet" href="/project/css/main.css">


<link rel="stylesheet" href="/project/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"hmt0.github.io","root":"/project/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta property="og:type" content="website">
<meta property="og:title" content="hmt的博客">
<meta property="og:url" content="https://hmt0.github.io/project/page/2/index.html">
<meta property="og:site_name" content="hmt的博客">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="He Mengting">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://hmt0.github.io/project/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'en'
  };
</script>

  <title>hmt的博客</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/project/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">hmt的博客</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/project/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/project/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/10/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAReact%E4%B8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/10/20/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAReact%E4%B8%8B/" class="post-title-link" itemprop="url">从0开始实现一个React下</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-20 23:00:10" itemprop="dateCreated datePublished" datetime="2021-10-20T23:00:10+08:00">2021-10-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>书接上回，我们已经实现了<code>createElement</code>函数、<code>render</code>函数和Fibers，接下来就要开始处理组件更新的部分了~</p>
<h2 id="5-Render和Commit阶段"><a href="#5-Render和Commit阶段" class="headerlink" title="5.Render和Commit阶段"></a>5.<code>Render</code>和<code>Commit</code>阶段</h2><p>但在这之前！不知道你有没有注意到一个问题：在<code>performUnitOfWork</code>中每次我们处理一个元素时都会在DOM 中添加一个新的节点。而且，浏览器还会在完成整棵树的渲染之前打断我们的工作。这样，用户将会看到一个不完整的<code>UI</code>，这是我们不希望的。</p>
<p>所以我们把修改DOM的这部分代码移除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;performUnitOfWork&quot;</span>, fiber)</span><br><span class="line">    <span class="comment">// TODO add dom node</span></span><br><span class="line">    <span class="keyword">if</span>(!fiber.dom) &#123;</span><br><span class="line">        fiber.dom = createDom(fiber)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// TODO create new fibers</span></span><br><span class="line">    <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>并且在render函数中去跟踪fiber树的根节点，我们叫它“正在进行的工作”root或者<code>wipRoot</code>。</p>
<p>当我们完成了所有任务（也就是任务中没有下一个单元的时候），我们就把整个fiber树提交到DOM中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO add nodes to dom</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  wipRoot = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">  nextUnitOfWork = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> wipRoot = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123;</span><br><span class="line">    nextUnitOfWork = performUnitOfWork(</span><br><span class="line">      nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!nextUnitOfWork &amp;&amp; wipRoot) &#123;</span><br><span class="line">    commitRoot()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestIdleCallback(workLoop)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们在<code>commitRoot</code>函数中完成提交。这里我们递归地将所有节点添加到DOM中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  domParent.appendChild(fiber.dom)</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（也就是不断执行<code>requestIdleCallback(workLoop)</code>生成fiber树，修改DOM的操作集中在commit阶段）</p>
<h2 id="6-协调"><a href="#6-协调" class="headerlink" title="6.协调"></a>6.协调</h2><p>带目前为止我们只是在DOM中添加东西，怎么去更新或者删除节点呢？</p>
<p>这就是所谓的协调（reconciliation）了，我们需要将在<code>render</code>函数上接收到的元素与提交给DOM的最后一个fiber树进行比较。</p>
<p>所以完成提交后，我们需要保存“上一个提交到DOM的fiber树”的引用。我们称它为<code>currentRoot</code>。</p>
<p>我们还要为每一个fiber添加一个<code>alternate</code>属性。这个属性是到到旧fiber的链接，也就是我们在上一次提交阶段中提交到DOM中的fiber。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	currentRoot = wipRoot</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funciton <span class="function"><span class="title">render</span>(<span class="params">element, container</span>)</span> &#123;</span><br><span class="line">	wipRoot = &#123;</span><br><span class="line">		...</span><br><span class="line">		<span class="attr">alternate</span>: currentRoot</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> currentRoot = <span class="literal">null</span></span><br></pre></td></tr></table></figure>

<p>现在让我们把创建新fibers的代码从<code>performUnitOfWork</code>中提取出来，放在一个新的<code>reconcileChildren</code>函数中。在这里我们把旧fibers和新元素调和起来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">    reconcileChildren(fiber, element)</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reconcileChildren</span>(<span class="params">wipFiber, elements</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<p>我们同时迭代旧fiber的孩子（<code>wipFiber.alternate</code>）和我们想调和的元素数组。</p>
<p>如果忽略同时遍历一个数组和链表的模板代码，在while循环中只剩下最重要的部分：<code>oldFiber</code>和<code>element</code>。**<code>element</code>是我们想渲染在DOM中的东西，<code>oldFiber</code>则是我们上次的渲染的内容。**</p>
<p>我们需要比较它们，来看看是不是有需要应用在DOM中的更改：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> oldFiber =</span><br><span class="line">    wipFiber.alternate &amp;&amp; wipFiber.alternate.child</span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (</span><br><span class="line">    index &lt; elements.length ||</span><br><span class="line">    oldFiber != <span class="literal">null</span></span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line">    <span class="keyword">let</span> newFiber = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO compare oldFiber to element</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>我们使用类型来比较它们：</p>
<ul>
<li>如果旧fiber和新元素类型一样，我们可以保留DOM节点并且只更新的属性</li>
<li>如果类型不同，并且存在新元素，意味着我们需要创建一个新的DOM节点</li>
<li>如果类型不同，并且存在旧fiber，我们需要移除旧节点</li>
</ul>
<p>在这里React还用了keys，来实现更高效的调和。比如，它检测子元素在元素数组中的位置何时改变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sameType =</span><br><span class="line">    oldFiber &amp;&amp;</span><br><span class="line">    element &amp;&amp;</span><br><span class="line">    element.type == oldFiber.type</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">    <span class="comment">// TODO update the node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">    <span class="comment">// TODO add this node</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">    <span class="comment">// TODO delete the oldFiber&#x27;s node</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>当旧fiber和元素有相同的类型时，我们创建一个新fiber，使DOM节点和旧fiber保持一致，属性和元素保持一致。</p>
<p>我们还给fiber添加了一个新的属性：<code>effectTag</code>。接下来，我们将在提交阶段使用这个属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sameType =</span><br><span class="line">      oldFiber &amp;&amp;</span><br><span class="line">      element &amp;&amp;</span><br><span class="line">      element.type == oldFiber.type</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: oldFiber.type,</span><br><span class="line">        <span class="attr">props</span>: element.props,</span><br><span class="line">        <span class="attr">dom</span>: oldFiber.dom,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: oldFiber,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&quot;UPDATE&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于需要一个新的DOM节点的元素，我们用<code>PLACEMENT</code>来标记新fiber：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (element &amp;&amp; !sameType) &#123;</span><br><span class="line">      newFiber = &#123;</span><br><span class="line">        <span class="attr">type</span>: element.type,</span><br><span class="line">        <span class="attr">props</span>: element.props,</span><br><span class="line">        <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">parent</span>: wipFiber,</span><br><span class="line">        <span class="attr">alternate</span>: <span class="literal">null</span>,</span><br><span class="line">        <span class="attr">effectTag</span>: <span class="string">&quot;PLACEMENT&quot;</span>,</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>对于需要删除节点的情况，我们不需要新fiber，只要在旧fiber上添加effect tag就好了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (oldFiber &amp;&amp; !sameType) &#123;</span><br><span class="line">     oldFiber.effectTag = <span class="string">&quot;DELETION&quot;</span></span><br><span class="line">     deletions.push(oldFiber)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

<p>但是，当我们把fiber树提交到DOM时，我们从“正在工作中的”根执行，它并没有旧fibers呀。</p>
<p>因此我们需要一个数组deletions来跟踪想要移除的节点。接着，当我们向DOM提交更改时，我们仍然使用deletions数组中的fibers：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitRoot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  deletions.forEach(commitWork)</span><br><span class="line">  commitWork(wipRoot.child)</span><br><span class="line">  currentRoot = wipRoot</span><br><span class="line">  wipRoot = <span class="literal">null</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在，让我们修改<code>commitWork</code>函数来处理新的<code>effectTags</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">  domParent.appendChild(fiber.dom)</span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果fiber的effect tag值是<code>PLACEMENT</code>，我们和之前做的一样，把DOM节点追加到父fiber的节点上；</p>
<p>如果是<code>DELETION</code>,则相反，我们要删除子节点；</p>
<p>如果是<code>UPDATE</code>，我们需要用更改后的属性更新现存的DOM节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber) &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> domParent = fiber.parent.dom</span><br><span class="line">   <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">   ) &#123;</span><br><span class="line">       domParent.appendChild(fiber.dom)</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (</span><br><span class="line">    fiber.effectTag === <span class="string">&quot;UPDATE&quot;</span> &amp;&amp;</span><br><span class="line">    fiber.dom != <span class="literal">null</span></span><br><span class="line">   ) &#123;</span><br><span class="line">       updateDom(</span><br><span class="line">           fiber.dom,</span><br><span class="line">           fiber.alternate.props,</span><br><span class="line">           fiber.props</span><br><span class="line">       ) </span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (fiber.effectTag === <span class="string">&quot;DELETION&quot;</span>) &#123;</span><br><span class="line">     domParent.removeChild(fiber.dom)</span><br><span class="line">   &#125; </span><br><span class="line">  commitWork(fiber.child)</span><br><span class="line">  commitWork(fiber.sibling)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们把更新的操作写在<code>updateDom</code>函数中：我们对比新旧fibers的属性，移除无用属性，设置新的或改变的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line"><span class="keyword">const</span> isNew = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">  prev[key] !== next[key]</span><br><span class="line"><span class="keyword">const</span> isGone = <span class="function">(<span class="params">prev, next</span>) =&gt;</span> <span class="function"><span class="params">key</span> =&gt;</span> !(key <span class="keyword">in</span> next)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateDom</span>(<span class="params">dom, prevProps, nextProps</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// Remove old properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isGone(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = <span class="string">&quot;&quot;</span></span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Set new or changed properties</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .filter(isNew(prevProps, nextProps))</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = nextProps[name]</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于事件监听属性我们需要做特殊处理，也就是属性名以“on”前缀开头的属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isEvent = <span class="function"><span class="params">key</span> =&gt;</span> key.startsWith(<span class="string">&quot;on&quot;</span>)</span><br><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">  key !== <span class="string">&quot;children&quot;</span> &amp;&amp; !isEvent(key)</span><br></pre></td></tr></table></figure>

<p>如果事件处理程序发生了改变，我们把它从节点中移除：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Remove old or changed event listeners</span></span><br><span class="line"><span class="built_in">Object</span>.keys(prevProps)</span><br><span class="line">  .filter(isEvent)</span><br><span class="line">  .filter(</span><br><span class="line">    <span class="function"><span class="params">key</span> =&gt;</span></span><br><span class="line">      !(key <span class="keyword">in</span> nextProps) ||</span><br><span class="line">      isNew(prevProps, nextProps)(key)</span><br><span class="line">  )</span><br><span class="line">  .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> eventType = name</span><br><span class="line">      .toLowerCase()</span><br><span class="line">      .substring(<span class="number">2</span>)</span><br><span class="line">    dom.removeEventListener(</span><br><span class="line">      eventType,</span><br><span class="line">      prevProps[name]</span><br><span class="line">    )</span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>

<p>然后添加一个新的处理程序：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Add event listeners</span></span><br><span class="line"> <span class="built_in">Object</span>.keys(nextProps)</span><br><span class="line">   .filter(isEvent)</span><br><span class="line">   .filter(isNew(prevProps, nextProps))</span><br><span class="line">   .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> eventType = name</span><br><span class="line">       .toLowerCase()</span><br><span class="line">       .substring(<span class="number">2</span>)</span><br><span class="line">     dom.addEventListener(</span><br><span class="line">       eventType,</span><br><span class="line">       nextProps[name]</span><br><span class="line">     )</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>

<p>（其实就是初次渲染的时候要从头（根）到尾（叶）生成一棵fiber树，之后有更新只需要调整部分节点，保留不变的节点）</p>
<h2 id="7-函数组件"><a href="#7-函数组件" class="headerlink" title="7.函数组件"></a>7.函数组件</h2><p>接下来我们要做的是支持函数式组件。首先让我们把原来的例子修改成函数式组件，它返回一个<code>h1</code>元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hi &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">App</span> <span class="attr">name</span>=<span class="string">&quot;foo&quot;</span> /&gt;</span></span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line">Didact.render(element, container)</span><br></pre></td></tr></table></figure>

<p>如果把JSX语法转换成JS呢，应该是下面这样的:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> Didact.createElement(</span><br><span class="line">    <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">    <span class="literal">null</span>,</span><br><span class="line">    <span class="string">&quot;Hi &quot;</span>,</span><br><span class="line">    props.name</span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = Didact.createElement(App, &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>函数式组件有两个不同点：</p>
<ul>
<li>函数式组件的fiber（本身）没有DOM节点（本身是由其他由DOM节点的fiber组成的嘛）</li>
<li>而且组件的孩子来自于函数的执行而不是直接来自于<code>props</code></li>
</ul>
<p>我们检查fiber type是不是一个函数，然后据此切换到一个不同的更新函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isFunctionComponent =</span><br><span class="line">    fiber.type <span class="keyword">instanceof</span> <span class="built_in">Function</span></span><br><span class="line">  <span class="keyword">if</span> (isFunctionComponent) &#123;</span><br><span class="line">    updateFunctionComponent(fiber)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    updateHostComponent(fiber)</span><br></pre></td></tr></table></figure>

<p>在<code>updateHostComponent</code>中我们做的事和之前一样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">function <span class="title">updateFunctionComponent</span><span class="params">(fiber)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">function <span class="title">updateHostComponent</span><span class="params">(fiber)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line">  reconcileChildren(fiber, fiber.props.children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而在<code>updateFunctionComponent</code>中我们运行函数来获得children。</p>
<p>在我们的例子中，这里的<code>fiber.type</code>是<code>App</code>函数，当我们运行它时会返回一个<code>h1</code>元素。</p>
<p>接着，一旦我们得到了children，调和函数也会以同样的方式执行，我们不需要对它做任何修改</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们需要修改的是<code>commitWork</code>函数，现在我们的到了一些没有DOM节点的fibers，我们要修改两件事。</p>
<p>首先，为了找到DOM节点的父亲，我们需要在fiber tree中向上查找，直到找到了拥有DOM节点的fiber：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> domParentFiber = fiber.parent</span><br><span class="line"> <span class="keyword">while</span> (!domParentFiber.dom) &#123;</span><br><span class="line">   domParentFiber = domParentFiber.parent</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">const</span> domParent = domParentFiber.dom</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (</span><br><span class="line">   fiber.effectTag === <span class="string">&quot;PLACEMENT&quot;</span> &amp;&amp;</span><br><span class="line">   fiber.dom != <span class="literal">null</span></span><br><span class="line"> ) &#123;</span><br><span class="line">   domParent.appendChild(fiber.dom)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>接着当删除节点时，我们也需要继续查找，直到找到一个具有DOM节点的子元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">commitDeletion</span>(<span class="params">fiber, domParent</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (fiber.dom) &#123;</span><br><span class="line">    domParent.removeChild(fiber.dom)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    commitDeletion(fiber.child, domParent)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="8-Hooks"><a href="#8-Hooks" class="headerlink" title="8.Hooks"></a>8.<code>Hooks</code></h2><p>最后一步了！现在我们实现了函数式组件，现在让我们加入状态。</p>
<p>让我们写一个经典的计数器例子。每次我们点击它，它的state就加一。注意我们用的是<code>Diadact.useState</code>来获取和更新counter值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Counter</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> [state, setState] = Didact.useState(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">onClick</span>=<span class="string">&#123;()</span> =&gt;</span> setState(c =&gt; c + 1)&#125;&gt;</span></span><br><span class="line"><span class="xml">      Count: &#123;state&#125;</span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  )</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Counter</span> /&gt;</span></span></span><br></pre></td></tr></table></figure>

<p><code>updateFunctionComponent</code>是我们调用示例中<code>Counter</code>函数的地方，在<strong>函数内部</strong>我们还调用了<code>useState</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在调用函数组件之前，我们需要初始化一些全局变量，供我们在<code>useState</code>函数中使用。</p>
<p>首先，我们定义“正在工作的”fiber。</p>
<p>我们还在fiber中添加了<code>hooks</code>数组，来实现在一个组件中多次调用<code>useState</code>。同时我们跟踪当前的hook下标：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> wipFiber = <span class="literal">null</span></span><br><span class="line"><span class="keyword">let</span> hookIndex = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">updateFunctionComponent</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  wipFiber = fiber</span><br><span class="line">  hookIndex = <span class="number">0</span></span><br><span class="line">  wipFiber.hooks = []</span><br><span class="line">  <span class="keyword">const</span> children = [fiber.type(fiber.props)]</span><br><span class="line">  reconcileChildren(fiber, children)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当函数式组件调用<code>useState</code>时，我们检查是否有一个旧hook。我们用hook下标在fiber的<code>alternate</code>属性中检查。</p>
<p>如果我们有一个旧hook，就把旧hook中的state复制到新hook中，没有的话呢就初始化state。</p>
<p>接着我们把新hook添加到fiber，把hook下标加一，并且返回state：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">useState</span>(<span class="params">initial</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> oldHook =</span><br><span class="line">    wipFiber.alternate &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks &amp;&amp;</span><br><span class="line">    wipFiber.alternate.hooks[hookIndex]</span><br><span class="line">  <span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">state</span>: oldHook ? oldHook.state : initial,</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wipFiber.hooks.push(hook)</span><br><span class="line">  hookIndex++</span><br><span class="line">  <span class="keyword">return</span> [hook.state]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>useState</code>还应该返回一个更新state的函数，所以我们定义一个<code>setState</code>函数来接收一个动作（在<code>Counter</code>例子中这个动作是把state加一的函数）。</p>
<p>我们把这个动作推入一个队列，这个队列是添加在hook上的。</p>
<p>接下来我们要做的事和之前在<code>render</code>函数中的类似，设置一个新的“工作中的”root作为任务的下一个单元，使workLoop能开启一个新的渲染阶段：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> hook = &#123;</span><br><span class="line">    <span class="attr">state</span>: oldHook ? oldHook.state : initial,</span><br><span class="line">    <span class="attr">queue</span>: [],</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> setState = <span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.queue.push(action)</span><br><span class="line">    wipRoot = &#123;</span><br><span class="line">      <span class="attr">dom</span>: currentRoot.dom,</span><br><span class="line">      <span class="attr">props</span>: currentRoot.props,</span><br><span class="line">      <span class="attr">alternate</span>: currentRoot,</span><br><span class="line">    &#125;</span><br><span class="line">    nextUnitOfWork = wipRoot</span><br><span class="line">    deletions = []</span><br><span class="line">  &#125;</span><br><span class="line">​</span><br><span class="line">  wipFiber.hooks.push(hook)</span><br><span class="line">  hookIndex++</span><br><span class="line">  <span class="keyword">return</span> [hook.state, setState]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们还没执行动作呢！</p>
<p>我们在<strong>下次渲染组件的时候</strong>再执行，我们从旧hook队列中拿到所有动作，再把他们一个个应用在新hook state上，所以当我们返回state的时候它已经更新过了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> actions = oldHook ? oldHook.queue : []</span><br><span class="line">actions.forEach(<span class="function"><span class="params">action</span> =&gt;</span> &#123;</span><br><span class="line">    hook.state = action(hook.state)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>大功告成！我们写了一个自己的React😀</p>
<p>下面我们来复习一下整个过程8：</p>
<p>render:</p>
<p><img src="C:\Users\luna6\AppData\Roaming\Typora\typora-user-images\image-20211028180235291.png" alt="image-20211028180235291"></p>
<p>hookindex是干嘛的？</p>
<p>每次触发一个更新，调用setState函数，都会更新nextUnitOfWork，开始新一轮的重新渲染</p>
<p>此时fiber一定是函数组件，index在更新函数中初始化为0</p>
<p>生成children的就是执行函数的过程</p>
<p>会挨个执行useState函数</p>
<p>初始化的时候不执行setState的回调</p>
<p>但是在之后的更新中，需要拿到上一个fiber状态中保存的对应useState,setState回调队列，因为不是每一个setState都执行</p>
<p>可能再一次事件中调用了多个setState</p>
<p>在执行setState的过程中，并不会直接改变状态的值</p>
<p>而是把回调函数推到hook队列中，同时更新nextUnitOfWork，浏览器一旦有空闲就会重新渲染</p>
<p>比如调用了5个useState，在第三个useState的时候浏览器重新渲染</p>
<p>前两个useState是没有被打断的，那么hookIndex递增到了2</p>
<p>第三个的时候，又有五个useState要执行，就要从0开始了</p>
<p>则意味着hookIndex置为0，而且又要重新执行5个useState</p>
<p>由于idle的存在，可能队列中有多个action</p>
<p>当执行perform的时候，index初始化为0，又开始执行useState</p>
<p>这时wipFiber.alternate.hooks不为空，而且hookindex也有值</p>
<p>主要是setState和useState执行顺序的问题</p>
<p>栈</p>
<p>为了让新的hook能够和旧的hook联系起来</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/10/17/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAReact/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/10/17/%E4%BB%8E0%E5%BC%80%E5%A7%8B%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AAReact/" class="post-title-link" itemprop="url">从0开始实现一个React</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-17 12:18:53" itemprop="dateCreated datePublished" datetime="2021-10-17T12:18:53+08:00">2021-10-17</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>最近看到一篇<a target="_blank" rel="noopener" href="https://pomb.us/build-your-own-react/">教你构建一个React</a> 的文章，感觉写的很好，而且交互也做得特别棒，在此翻译记录一下。</p>
<p>这篇文章的主要目的是遵循React代码的体系结构一步步地写出一个简单的React，但没有所有的优化和非必要的功能。</p>
<p>过程分为以下几个步骤：</p>
<ol>
<li>The <code>createElement</code> Function</li>
<li>The <code>render</code> Function</li>
<li>并发模型</li>
<li>Fibers</li>
<li>渲染和提交阶段</li>
<li>协调</li>
<li>函数组件</li>
<li>Hooks</li>
</ol>
<h2 id="1：准备"><a href="#1：准备" class="headerlink" title="-1：准备"></a>-1：准备</h2><p>首先，<code>JSX</code>语法是通过Babel转换成JavaScript的，因此我们需要在项目中配置Babel。</p>
<p>安装：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save-dev @babel/core @babel/cli @babel/preset-env @babel/preset-react</span><br></pre></td></tr></table></figure>

<p>在根目录中添加<code>.babelrc</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/preset-env&quot;</span>, <span class="string">&quot;@babel/preset-react&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>.babel.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> presets = [</span><br><span class="line">  [</span><br><span class="line">    <span class="string">&quot;@babel/env&quot;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">targets</span>: &#123;</span><br><span class="line">        <span class="attr">edge</span>: <span class="string">&quot;17&quot;</span>,</span><br><span class="line">        <span class="attr">firefox</span>: <span class="string">&quot;60&quot;</span>,</span><br><span class="line">        <span class="attr">chrome</span>: <span class="string">&quot;67&quot;</span>,</span><br><span class="line">        <span class="attr">safari</span>: <span class="string">&quot;11.1&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="attr">useBuiltIns</span>: <span class="string">&quot;usage&quot;</span>,</span><br><span class="line">      <span class="attr">corejs</span>: <span class="string">&quot;3.6.4&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; presets &#125;;</span><br></pre></td></tr></table></figure>

<p>运行<code>npx babel src --out-dir lib</code>就可以把转换结果保存在lib文件夹下面了~</p>
<h2 id="0：回顾"><a href="#0：回顾" class="headerlink" title="0：回顾"></a>0：回顾</h2><p>下面的代码展示了渲染一个React组件的过程：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">title</span>=<span class="string">&quot;foo&quot;</span>&gt;</span>Hello<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span> <span class="comment">// 定义React组件</span></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>) <span class="comment">// 从DOM中获取一个节点container</span></span><br><span class="line">ReactDOM.render(element, container) <span class="comment">// 把React组件渲染到container</span></span><br></pre></td></tr></table></figure>

<p>要实现一个React，首先要知道React的方法是如何实现的，用原生的JavaScript怎么写，再去封装成我们的方法。现在，让我们不使用React语法来实现一下这个过程。</p>
<ol>
<li><h4 id="定义组件"><a href="#定义组件" class="headerlink" title="定义组件"></a>定义组件</h4></li>
</ol>
<p>Babel转换<code>JSX</code>的规则就是用调用<code>createElement</code>替换<code>&lt;&gt;</code>内部的代码，将<code>tag name</code>、<code>props</code>和子元素作为参数传递：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  <span class="string">&quot;Hello&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p><code>React.createElement</code>会对参数做一些验证并返回一个对象，长这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以直接用这个对象替换函数调用。<code>type</code>属性是一个字符串，表明DOM节点的类型，就是在生成HTML元素时将要传给<code>document.createElement</code>的<code>tagName</code>。</p>
<p><code>props</code>属性是一个对象，包括<code>JSX</code>属性的所有键值对，还有一个特殊的属性：<code>children</code>：</p>
<p>在这个例子中<code>children</code>是一个字符串，但是它通常是一个包含多个元素的数组。所以元素实数型结构的。</p>
<ol start="2">
<li><h4 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h4></li>
</ol>
<p>（<code>container</code>是直接调用<code>document.getElementById</code>获取的不用管。）另一个我们要替换的React代码是<code>ReactDOM.render</code>的调用。<code>render</code>是React修改DOM的地方，因此我们要在这里实现DOM更新。</p>
<p>首先我们用<code>type</code>属性创建一个节点*，本例中是<code>h1</code>。然后我们把元素的元素的属性分配给节点，本例中是title属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">&quot;title&quot;</span>] = element.props.title</span><br></pre></td></tr></table></figure>

<p>*为了避免混淆，下文中使用”元素”表示React元素，“节点”表示DOM节点。</p>
<p>接下来我们创建子节点，本例中只有一个文本节点。使用<code>textNode</code>而不是<code>innerText</code>可以让我们用同样的方式处理所有元素（方便递归）。注意我们像处理<code>h1</code>的title一样给文本节点设置<code>nodeValue</code>：<code>&#123;nodeValue: &quot;hello&quot;&#125;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">text[<span class="string">&quot;nodeValue&quot;</span>] = element.props.children</span><br></pre></td></tr></table></figure>

<p>最后，我们把<code>textNode</code>添加到<code>h1</code>，再把<code>h1</code>添加到<code>container</code>。</p>
<p>这样我们就在不使用React的情况下实现了同样的功能。罗嗦了这么多，实现起来还是很简单的，用过React的同学应该都很熟悉：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="attr">type</span>: <span class="string">&quot;h1&quot;</span>,</span><br><span class="line">  <span class="attr">props</span>: &#123;</span><br><span class="line">    <span class="attr">title</span>: <span class="string">&quot;foo&quot;</span>,</span><br><span class="line">    <span class="attr">children</span>: <span class="string">&quot;Hello&quot;</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> container = <span class="built_in">document</span>.getElementById(<span class="string">&quot;root&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> node = <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line">node[<span class="string">&quot;title&quot;</span>] = element.props.title</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> text = <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">text[<span class="string">&quot;nodeValue&quot;</span>] = element.props.children</span><br><span class="line"></span><br><span class="line">node.appendChild(text)</span><br><span class="line">container.appendChild(node)</span><br></pre></td></tr></table></figure>

<h2 id="1：createElement函数"><a href="#1：createElement函数" class="headerlink" title="1：createElement函数"></a>1：<code>createElement</code>函数</h2><p>（上一步中，我们直接定义了element对象）接下来，我们就该真正实现一个自己的<code>createElement</code>函数了。首先把<code>JSX</code>转换成<code>JS</code>研究一下<code>createElement</code>是如何调用的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = React.createElement(</span><br><span class="line">  <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  &#123; <span class="attr">id</span>: <span class="string">&quot;foo&quot;</span> &#125;,</span><br><span class="line">  React.createElement(<span class="string">&quot;a&quot;</span>, <span class="literal">null</span>, <span class="string">&quot;bar&quot;</span>),</span><br><span class="line">  React.createElement(<span class="string">&quot;b&quot;</span>)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>还记得我们上一步中定义的element对象吗？我们的函数的功能应该是创建一个具有<code>type</code>和<code>props</code>属性的对象：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createElement</span>(<span class="params">type, props, ...children</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    type,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      children,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里使用了展开运算符处理<code>props</code>，使用剩余参数处理<code>children</code>，因为我们希望<code>children</code>属性是一个数组。例如，<code>createElement(&quot;div&quot;)</code>返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElement(&quot;div&quot;, null, a)</code>返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [a] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>createElement(&quot;div&quot;, null, a, b)</code>返回</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;div&quot;</span>,</span><br><span class="line">  <span class="string">&quot;props&quot;</span>: &#123; <span class="string">&quot;children&quot;</span>: [a, b] &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>children</code>数组或许包含字符串或数字这样的原始值（树中的叶子节点）。所以我们应该包装不是对象的元素，再给它们一个特殊的属性：<code>TEXT_ELEMENT</code>。</p>
<p>(这里的箭头函数我一开始多写了个大括号，然后就一直报错！)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">props: &#123;</span><br><span class="line">      ...props,</span><br><span class="line">      <span class="attr">children</span>: children.map(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">        <span class="keyword">typeof</span> child === <span class="string">&quot;object&quot;</span></span><br><span class="line">          ? child</span><br><span class="line">          : createTextElement(child)</span><br><span class="line">      ),</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createTextElement</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    <span class="attr">type</span>: <span class="string">&quot;TEXT_ELEMENT&quot;</span>,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">nodeValue</span>: text,</span><br><span class="line">      <span class="attr">children</span>: [],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当没有子元素时，React并没有包装原始值或创建空数组，但我们更希望简化代码而不是追求代码性能😀。</p>
<p>为了替换React，我们要给自己的库起个名字，就叫<code>Didact</code>吧！但是我们依然想使用<code>JSX</code>语法，怎么告诉<code>babel</code>要用<code>Didact</code>的<code>createElement</code>而不是<code>React</code>的呢？</p>
<p>用这样一个注释，当babel编译<code>JSX</code>时，就会使用我们定义的函数辣：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** <span class="doctag">@jsx </span>Didact.createElement */</span></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;foo&quot;</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">a</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">b</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<h2 id="2-render函数"><a href="#2-render函数" class="headerlink" title="2.render函数"></a>2.<code>render</code>函数</h2><p>接下来，我们要写一个自己的<code>ReactDOM.render</code>函数。现在呢，我们只关心向DOM中添加东西，之后我们再实现更新和删除。</p>
<p>我们先根据<code>element type</code>生成一个DOM节点，再把这个新节点添加到container。</p>
<p>我们要递归地对每个子节点执行相同的操作。别忘了文本元素，如果元素类型是<code>TEXT_ELEMENT</code>我们就会创建一个文本节点而不是常规节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    element.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(element.type)</span><br><span class="line"></span><br><span class="line">  element.props.children.forEach(<span class="function"><span class="params">child</span> =&gt;</span></span><br><span class="line">    render(child, dom)</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>

<p>最后我们需要给节点分配元素属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(element.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = element.props[name]</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure>

<p>完成！我们实现了一个可以把<code>JSX</code>渲染到DOM中的库。</p>
<h2 id="3-并发模型"><a href="#3-并发模型" class="headerlink" title="3.并发模型"></a>3.并发模型</h2><p>在实现更多功能前······我们需要重构一下代码。</p>
<p>因为我们的递归调用有一个问题。一旦我们开始渲染，直到我们渲染完整棵element树都不会停下来。如果这棵element树很大的话，它可能会使主线程阻塞很久。而且如果浏览器需要实现一段平滑的动画或者处理用户输入这种高优先级的任务，它将会一直等待直到渲染完成。</p>
<p>因此我们将把工作拆分成小的单元，而且每当我们完成了一个单元，如果有其他事情要做的话我们会让浏览器打断渲染。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> nextUnitOfWork = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">workLoop</span>(<span class="params">deadline</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> shouldYield = <span class="literal">false</span></span><br><span class="line">  <span class="keyword">while</span> (nextUnitOfWork &amp;&amp; !shouldYield) &#123; </span><br><span class="line">    <span class="comment">// 任务列表中还有下一个单元而且还有空闲时间</span></span><br><span class="line">    nextUnitOfWork = performUnitOfWork(</span><br><span class="line">      <span class="comment">// 执行任务</span></span><br><span class="line">      nextUnitOfWork</span><br><span class="line">    )</span><br><span class="line">    shouldYield = deadline.timeRemaining() &lt; <span class="number">1</span></span><br><span class="line">   	<span class="comment">// 判断是否还有空闲时间</span></span><br><span class="line">  &#125;</span><br><span class="line">  requestIdleCallback(workLoop)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">requestIdleCallback(workLoop)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">nextUnitOfWork</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们使用<code>requestIdleCallback</code>来实现循环。可以把<code>reuqestIdleCallback</code>看作一个<code>setTimeout    </code>,只不过不是我们告诉他什么时候运行，<strong>浏览器会在主线程空闲时运行回调函数</strong>。</p>
<p>React不再使用<code>requestIdleCallback</code>了，现在人家用<em>the scheduler package</em>，但在本例中是一样的概念。</p>
<p><code>requestIdleCallback</code>还给了我们一个deadline参数。我们就是用它来判断在浏览器获得掌控权之前我们还有多少时间的。</p>
<p>我们通过设置任务中的第一个单元来启动循环，接下来写了一个<code>performUnitOfWork</code>函数，即执行了任务又返回了任务中的下一个单元。</p>
<h2 id="4-Fibers"><a href="#4-Fibers" class="headerlink" title="4.Fibers"></a>4.<code>Fibers</code></h2><p>（现在我们还不知道<code>nextUnitOfWork</code>长啥样，也就无法实现<code>performUnitOfWork</code>）为了组织任务中的所有单元我们需要一种数据结构：那就是<code>fiber</code>树。</p>
<p>（Fiber就是我们经常说的”虚拟DOM“，其实就是先用一个对象来表述这个节点的自身属性和它的父亲儿子兄弟的关系）</p>
<p><strong>每一个元素都有一个对应的<code>fiber</code>而且每个<code>fiber</code>都是任务中的一个单元。</strong></p>
<p>让我们来看一个例子，假设我们想要渲染一个这样的element树：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Didact.render(</span><br><span class="line">  <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">p</span> /&gt;</span></span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;<span class="name">a</span> /&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">h2</span> /&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,</span><br><span class="line">  container</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>在<code>render</code>中我们将会创建一个<code>root fiber</code>，并把它设置为<code>nextUnitOfWork</code>。接下来的任务将会在<code>performUnitOfWork</code>中执行，我们将会对每个fiber做三件事情：</p>
<ol>
<li>把元素添加到DOM中</li>
<li>为元素的孩子创建<code>fibers</code></li>
<li>选择下一个任务</li>
</ol>
<p>（不知道你有没有看出来，其实还是递归，只不过我们没有在递归里面不假思索地渲染每一个节点！）</p>
<p>学过数据结构的同学都应该知道树长啥样：</p>
<p><img src="C:\Users\luna6\AppData\Roaming\Typora\typora-user-images\image-20211018223652632.png" alt="image-20211018223652632"></p>
<p>就长fiber树这样！其实是fiber树就长树这样😀选择这种数据结构当然是为了方便遍历了，每个fiber都链接着它的第一个孩子节点，相邻的兄弟节点和它的父节点。</p>
<p>当我们完成了一个fiber上的任务时，如果他有<code>child</code>节点，那么孩子fiber就会是任务执行的下一个单元。例如，当我们完成了<code>div</code>fiber上的任务时，下一个单元将会是<code>h1</code>fiber。</p>
<p>如果一个fiber没有<code>child</code>，我们把<code>sibling</code>当作任务的下一个单元。比如，<code>p</code>fiber没有<code>child</code>，所以我们在它完成之后来到了<code>a</code>fiber。</p>
<p>再如果一个fiber既没有<code>child</code>也没有<code>sibling</code>呢，我们找到它的“叔叔”：<code>parent</code>的<code>sibling</code>。就像<code>a</code>fiber和<code>h2</code>fiber的关系。</p>
<p>当然啦，如果<code>parent</code>也没有<code>sibling</code>的话，我们就一直顺着<code>parent</code>s向上找，直到找到了一个具有<code>sibling</code>的fiber或者到达了root。如果我们到达了root，也就意味着我们完成了此次<code>render</code>的所有任务。（熟悉数据结构的同学一定很开心吧！这不就是先根遍历的过程嘛😄）</p>
<p>接下来让我们实现代码部分：</p>
<p>首先把render函数中创建DOM节点部分的代码抽出来，放在一个单独的<code>createDom</code>函数中，稍后我们会用到它：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createDom</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> dom =</span><br><span class="line">    fiber.type == <span class="string">&quot;TEXT_ELEMENT&quot;</span></span><br><span class="line">      ? <span class="built_in">document</span>.createTextNode(<span class="string">&quot;&quot;</span>)</span><br><span class="line">      : <span class="built_in">document</span>.createElement(fiber.type)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">const</span> isProperty = <span class="function"><span class="params">key</span> =&gt;</span> key !== <span class="string">&quot;children&quot;</span></span><br><span class="line">  <span class="built_in">Object</span>.keys(fiber.props)</span><br><span class="line">    .filter(isProperty)</span><br><span class="line">    .forEach(<span class="function"><span class="params">name</span> =&gt;</span> &#123;</span><br><span class="line">      dom[name] = fiber.props[name]</span><br><span class="line">    &#125;)</span><br><span class="line">​</span><br><span class="line">  <span class="keyword">return</span> dom</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>render</code>函数中我们把fiber tree的root设置为<code>nextUnitOfWork</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">render</span>(<span class="params">element, container</span>) </span>&#123;</span><br><span class="line">  nextUnitOfWork = &#123;</span><br><span class="line">    <span class="attr">dom</span>: container,</span><br><span class="line">    <span class="attr">props</span>: &#123;</span><br><span class="line">      <span class="attr">children</span>: [element],</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来，当浏览器准备好时，它会回调我们的<code>workLoop</code>，我们将会从<code>root</code>开始执行任务。首先，我们创建一个新节点并把它添加到DOM中。我们用<code>fiber.dom</code>属性来跟踪这个DOM节点：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">performUnitOfWork</span>(<span class="params">fiber</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!fiber.dom) &#123;</span><br><span class="line">    fiber.dom = createDom(fiber)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (fiber.parent) &#123;</span><br><span class="line">    fiber.parent.dom.appendChild(fiber.dom)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// TODO create new fibers</span></span><br><span class="line">  <span class="comment">// TODO return next unit of work</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来我们为每个<code>child</code>创建一个新的fiber：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> elements = fiber.props.children</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">  <span class="keyword">let</span> prevSibling = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (index &lt; elements.length) &#123;</span><br><span class="line">    <span class="keyword">const</span> element = elements[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> newFiber = &#123;</span><br><span class="line">      <span class="attr">type</span>: element.type,</span><br><span class="line">      <span class="attr">props</span>: element.props,</span><br><span class="line">      <span class="attr">parent</span>: fiber,</span><br><span class="line">      <span class="attr">dom</span>: <span class="literal">null</span>,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>然后我们把它作为一个<code>child</code>或者<code>sibling</code>加入fiber tree，这取决于它是不是第一个<code>child</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (index === <span class="number">0</span>) &#123;</span><br><span class="line">      fiber.child = newFiber</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      prevSibling.sibling = newFiber</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    prevSibling = newFiber</span><br><span class="line">    index++</span><br></pre></td></tr></table></figure>

<p>最后我们寻找任务中的下一个单元。我们首先寻找<code>child</code>，接下来是<code>sibling</code>，然后是<code>uncle</code>，以此类推。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (fiber.child) &#123;</span><br><span class="line">   <span class="keyword">return</span> fiber.child</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="keyword">let</span> nextFiber = fiber</span><br><span class="line"> <span class="keyword">while</span> (nextFiber) &#123;</span><br><span class="line">   <span class="keyword">if</span> (nextFiber.sibling) &#123;</span><br><span class="line">     <span class="keyword">return</span> nextFiber.sibling</span><br><span class="line">   &#125;</span><br><span class="line">   nextFiber = nextFiber.parent</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这就是我们的<code>performUnitOfWork</code>辣！</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/10/12/test/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/10/12/test/" class="post-title-link" itemprop="url">test</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-10-12 20:47:34" itemprop="dateCreated datePublished" datetime="2021-10-12T20:47:34+08:00">2021-10-12</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>把hexo配置放在github上</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/23/%E7%BF%BB%E8%AF%91-viewports%E7%9A%84%E6%95%85%E4%BA%8B-part-one/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/23/%E7%BF%BB%E8%AF%91-viewports%E7%9A%84%E6%95%85%E4%BA%8B-part-one/" class="post-title-link" itemprop="url">翻译:viewports的故事-第一部分</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-23 15:11:28" itemprop="dateCreated datePublished" datetime="2021-09-23T15:11:28+08:00">2021-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>原文地址：<a target="_blank" rel="noopener" href="https://www.quirksmode.org/mobile/viewports.html">https://www.quirksmode.org/mobile/viewports.html</a></p>
<p>本文从像素的概念入手，介绍了浏览器窗口缩放带来的变化，<code>viewport</code>属性和获取<code>viewport</code>大小的属性。以下为翻译：</p>
<p><strong>在这个短系列中我将阐述<code>viewports</code>和一些重要的元素的widths属性是如何工作的，比如<html>标签、窗口和屏幕。</strong></p>
<p>这一篇是关于桌面浏览器的，它的唯一目的是为移动浏览器的类似讨论奠定基础。许多web开发者已经对许多有关桌面的概念有了直观的理解。在手机端我们将会看到相同的概念，只不过更加复杂，一个关于大家都知道的术语的先导讨论将会极大帮助地你理解手机浏览器。</p>
<h3 id="概念：设备像素和css像素"><a href="#概念：设备像素和css像素" class="headerlink" title="概念：设备像素和css像素"></a>概念：设备像素和<code>css</code>像素</h3><p>第一个需要理解的概念是<code>CSS</code>像素以及它和设备像素的区别。</p>
<p>设备像素就是我们直觉上认为“正确”的像素。这些像素就是你正在使用的设备的正式分辨率，通常可以通过<code>screen.width/height</code>读取。</p>
<p>如果你给某个元素设置<code>width: 128px</code>，而你的显示器的宽度是<code>1024px</code>，并且你把浏览器窗口最大化，那么这个元素可以在你的显示器上填充8次（粗略地;让我们忽略棘手的部分）。</p>
<p>然而，如果用户缩放，这个计算关系将会改变。如果用户放大至200%，你的<code>width: 128px</code>的元素将只能在<code>1024px</code>的显示器填充4次。</p>
<p>在现代浏览器中实现的缩放只不过是“扩展”像素。也就是说，不是元素的宽度从128变为256像素；而是<em>实际像素</em>的大小翻倍。形式上，元素的宽度仍然是128 <code>CSS</code>像素，即使它恰好占用256个设备像素的空间。</p>
<p>换句话说，放大200%使<code>CSS</code>像素扩大为设备像素的四倍。（宽度两倍，高度两倍，总共四倍）。</p>
<p>一些图片可以明确这些概念。这是在100%缩放级别的四个像素，<code>CSS</code>像素与设备像素完全重叠。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/csspixels_100.gif" alt="img"></p>
<p>现在让我们缩小。<code>CSS</code>像素开始收缩，这意味着一个设备像素现在重叠了几个<code>CSS</code>像素。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/csspixels_out.gif" alt="img"></p>
<p>如果你放大，会发生相反的情况。<code>CSS</code>像素开始增长，现在一个<code>CSS</code>像素重叠了几个设备像素。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/csspixels_in.gif" alt="img"></p>
<p>关键点在于<em>我们只关心<code>CSS</code>像素</em>。正是这些像素决定了样式表的呈现方式。</p>
<p>设备像素几乎没用。不是对用户；用户会放大或缩小页面，直到可以舒服地阅读它。然而，缩放级别对你来说并不重要。浏览器会自动确保你的<code>CSS</code>布局被拉伸或压缩。</p>
<p>（结论：缩小就是缩小<code>CSS</code>像素，放大就是放大<code>CSS</code>像素）</p>
<h3 id="100-缩放"><a href="#100-缩放" class="headerlink" title="100%缩放"></a>100%缩放</h3><p>我一开始用假设缩放级别为100%举例。现在是时候更严格地定义它了：</p>
<blockquote>
<p>在缩放级别100%，一个<code>CSS</code>像素完全等于一个设备像素。</p>
</blockquote>
<p>100%缩放的概念在接下来的说明中非常有用，但在日常工作中你不应该过度关注它。在桌面，你通常会用100%的缩放来测试你的网站，但即使用户放大或缩小，神奇的<code>CSS</code>像素也会确保你的布局保持相同的比例。</p>
<h3 id="屏幕尺寸-Screen-size"><a href="#屏幕尺寸-Screen-size" class="headerlink" title="屏幕尺寸 Screen size"></a>屏幕尺寸 Screen size</h3><p>让我们看看一些实际的测量方法。我们从<code>screen.width</code>和<code>screen.height</code>开始。它们包含用户屏幕的总宽度和高度。这些尺寸用设备像素来衡量，因为它们永远不会改变：它们是显示器的特性，而不是浏览器的特性。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_screen.jpg" alt="img"></p>
<p>有趣！但这些信息基本上没什么用。用户显示器的大小对我们来说并不重要，除非你想在web统计数据库中使用它。</p>
<h3 id="窗口尺寸-Window-size"><a href="#窗口尺寸-Window-size" class="headerlink" title="窗口尺寸 Window size"></a>窗口尺寸 Window size</h3><p>相反，我们想知道的是浏览器窗口的内部尺寸。它会告诉你用户当前有多少空间用来展示你的<code>CSS</code>布局。你可以通过<code>Window.innerWidth</code>和<code>window.innerHeight</code>来查询这些尺寸。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_inner.jpg" alt="img"></p>
<p>显然，窗口的内部宽度是以<code>CSS</code>像素衡量的。你需要知道你的布局有多少可以挤进浏览器窗口，并且这个数量会随着用户的放大而减少。如果用户放大你会得到更少的可用空间，<code>innerWidth/Height</code>的递减可以反映这一点。</p>
<p>（zoom的时候虽然看起来浏览器窗口大小没有变化，但是innerWidth变化了，就像放大镜效果一样，能看见内容的区域变化了）</p>
<p>（Opera是个例外，当用户放大时，它的<code>innerWidth/Height</code>不会减少：它们是以设备像素衡量的。这在台式机上很烦人，但在移动设备上却是致命的，我们稍后会看到。)</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_inner_zoomed.jpg" alt="img"></p>
<p>注意，测量的宽度和高度包括滚动条。它们也被认为是内窗的一部分。(这主要是由于历史原因。)</p>
<h3 id="滚动抵消-Scrolling-offset"><a href="#滚动抵消-Scrolling-offset" class="headerlink" title="滚动抵消 Scrolling offset"></a>滚动抵消 Scrolling offset</h3><p><code>window.pageXOffset</code>和<code>window.pageYOffset</code>包含文档的水平和垂直滚动偏移量。这样你就可以知道用户滚动了多少。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_page.jpg" alt="img"></p>
<p>这些属性也是用<code>CSS</code>像素度量的。你想知道文档已经向上滚动了多少，不管缩放状态是什么。</p>
<p>理论上，如果用户向上滚动，然后放大，<code>windw.pageX / YOffset</code>会改变。然而，浏览器试图保持网页的一致性，通过当用户放大时，在可见页面的顶部保持相同的元素来实现。这并不总是完美的，但这意味着在实践中<code>window.pageX/YOffset</code>并没有真正改变：已经滚动出窗口的<code>CSS</code>像素数量保持(大致)相同。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_page_zoomed.jpg" alt="img"></p>
<h3 id="概念-视口the-viewport"><a href="#概念-视口the-viewport" class="headerlink" title="概念: 视口the viewport"></a>概念: 视口the <code>viewport</code></h3><p>在我们继续讨论更多的JavaScript属性之前，我们必须引入另一个概念：视口 <code>the viewport</code>。</p>
<p><code>viewport</code>的功能是约束<html>元素，它是网页最上面的包含块。</p>
<p>这听起来可能有点模糊，所以这里有一个实际的例子。假设你有一个流式布局，其中一个侧边栏宽度为10%。现在，边栏会随着你调整浏览器窗口的大小而整齐地增长和收缩。但这到底是怎么回事呢?</p>
<p>从技术上讲，侧边栏的宽度是其父栏的10%。我们假设这是<body>(并且你没有给它设置宽度)。问题是<body>的宽度是多少。</p>
<p>通常情况下，所有块级元素的宽度都是其父元素的100%(当然也有例外，但我们先忽略它们)。所以<body>和它的父元素<html>一样宽。</p>
<html>元素有多宽？它和浏览器窗口一样宽。这就是为什么你的侧边栏`width:10%`将跨越整个浏览器窗口的10%。所有的web开发人员都直观地知道并使用这个事实。

<p>你可能不知道这在理论上是如何运作的。理论上，<html>元素的宽度受<code>viewport</code>宽度的限制。<html>元素占<code>viewport</code>宽度的100%。</p>
<p><code>viewport</code>，反过来，完全等于浏览器窗口：它是这样定义的。<code>viewport</code>不是HTML构造，因此不能通过<code>CSS</code>来影响它。它只是桌面浏览器窗口的宽度和高度。在移动平台上则要复杂得多。</p>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>这种情况产生了一些奇怪的后果。你可以在这个网站上看到其中一个。一直滚动到顶部，放大两到三倍，这样网站的内容就会溢出浏览器窗口。</p>
<p>现在向右滚动，你会看到网站顶部的蓝色条不再正确排列。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_htmlbehaviour.jpg" alt="img"></p>
<p>这种行为是<code>viewport</code>定义方式的结果。我给顶部的蓝色条定义<code>width:100%</code>。是谁的100%？<html>元素，它与<code>viewport</code>一样宽，<code>viewport</code>与浏览器窗口一样宽。</p>
<p>关键点在于：虽然在100%缩放时可以正常工作，但现在我们已经缩小了<code>viewport</code>，它比我的网站的总宽度还小。这本身并不重要，内容现在从<html>元素溢出，但该元素具有<code>overflow: visible</code>，这意味着溢出的内容将在任何情况下显示。</p>
<p>但是蓝色的条并没有溢出来。因为我给它设置了<code>width:100%</code>，毕竟，浏览器通过把<code>viewport</code>的宽度应用在蓝色条上来遵守这一设置。他们并不关心宽度现在太窄了。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_100percent.jpg" alt="img"></p>
<h3 id="文档宽度"><a href="#文档宽度" class="headerlink" title="文档宽度?"></a>文档宽度?</h3><p>我真正需要知道的是整个页面的内容有多宽，包括那些突出的部分。据我所知，不可能找到这个值(除非你去计算页面上所有元素的宽度和页边距，但说得委婉些，这很容易出错)。</p>
<p>我相信我们需要一个JavaScript属性对，来给出我所说的“文档宽度”(显然是<code>CSS</code>像素)。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_documentwidth.jpg" alt="img"></p>
<p>如果我们真的觉得很难，为什么不把这个值也暴露给<code>CSS</code>呢？我希望能够使蓝色条的<code>width:100%</code>属性依赖于文档的宽度，而不是<html>元素的宽度。(不过，这肯定很棘手，如果无法实现，我也不会感到惊讶。)</p>
<p>浏览器厂商们，你们怎么看?</p>
<h3 id="测量viewport"><a href="#测量viewport" class="headerlink" title="测量viewport"></a>测量<code>viewport</code></h3><p>你可能想知道视口的尺寸。它们可以在<code>document.documentElement.clientWidth</code>和<code>-Height</code>中找到。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_client.jpg" alt="img"></p>
<p>如果了解DOM，就会了解<code>document.documentElement</code>实际上是<html>元素：任何<code>html</code>文档的根元素。然而，可以说视口更高一级；它是包含<html>元素的元素。如果给<html>元素一个宽度，这可能很重要。(顺便说一下，我不建议这么做，但这是可能的。)</p>
<p>在这种情况下，<code>document.documentElement.clientWidth</code>和<code>-Height</code>仍然给出视口的尺寸，而不是<html>元素的尺寸。(这是一个特殊的规则，只适用于这个元素，只适用于这个属性对。在所有其他情况下，使用元素的实际宽度。)</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_client_smallpage.jpg" alt="img"></p>
<p>因此<code>document.documentElement.clientWidth</code>和<code>-Height</code>总是给出视口的尺寸，而不管<html>元素的尺寸。</p>
<h3 id="两个属性对"><a href="#两个属性对" class="headerlink" title="两个属性对"></a>两个属性对</h3><p>但是视窗宽度的尺寸不也是由<code>window.innerWidth/Height</code>给出的吗?是也不是。</p>
<p>这两个属性对之间有一个形式上的区别：<code>document.documentElement.clientWidth</code>和<code>-Height</code>不包括滚动条，而<code>window.innerWidth/Height</code>包括。不过，这基本上是一种吹毛求疵。</p>
<p>我们有两个属性对的现状是浏览器之战遗留下来的。那时<code>Netscape</code>只支持<code>window.innerWidth/Height</code>而IE仅支持<code>document.documentElement.clientWidth</code>和<code>-Height</code>。从那时起，所有其他浏览器都开始支持<code>clientWidth/Height</code>，但IE没有选择<code>window.innerWidth/Height</code>。</p>
<p>在台式机上有两个可用的属性对是一个小麻烦——但在移动设备上却是一个福音，正如我们将看到的。</p>
<h3 id="测量元素"><a href="#测量元素" class="headerlink" title="测量元素"></a>测量<html>元素</h3><p>所以<code>clientWidth/Height</code>给出了所有情况下的视口尺寸。但是我们在哪里可以找到<html>元素本身的尺寸呢?它们存储在<code>document.documentElement.offsewidth</code>和<code>-Height</code>中。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_offset.jpg" alt="img"></p>
<p>这些属性真正地让你以块级元素的方式访问<html>元素；如果你设置<code>width</code>，<code>offsetWidth</code>将反映它。</p>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_offset_smallpage.jpg" alt="img"></p>
<h3 id="事件的坐标"><a href="#事件的坐标" class="headerlink" title="事件的坐标"></a>事件的坐标</h3><p>然后是事件坐标。当鼠标事件发生时，至少会暴露5个属性对以提供有关事件确切位置的信息。对于我们的讨论，其中三个是重要的：</p>
<blockquote>
<ol>
<li><code>pageX/Y</code>以<code>CSS</code>像素给出元素相对于<html>元素的坐标。</li>
<li><code>clientX/Y</code>以<code>CSS</code>像素给出元素相对于<code>viewport</code>的元素坐标。</li>
<li><code>screenX/Y</code> 以<code>CSS</code>像素给出相对于屏幕的坐标。</li>
</ol>
</blockquote>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_pageXY.jpg" alt="img"></p>
<p>90%的时间你都会都使用<code>pageX/Y</code>；通常，你想知道事件相对于文档的位置。另外10%的时间你会使用<code>clientX/Y</code>。您永远不需要知道相对于屏幕的事件坐标。</p>
<h3 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h3><p>最后，一些关于媒体查询的词汇。其思想非常简单：您可以定义特殊的<code>CSS</code>规则，这些规则只在页面宽度大于、等于或小于特定大小时执行。例如：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">div</span><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">	<span class="attribute">width</span>: <span class="number">300px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">@media</span> all <span class="keyword">and</span> (<span class="attribute">max-width</span>: <span class="number">400px</span>) &#123;</span><br><span class="line">	// styles assigned when <span class="attribute">width</span> is smaller than <span class="number">400px</span>;</span><br><span class="line">	<span class="selector-tag">div</span><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">		<span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在侧边栏是<code>300px</code>宽，除非宽度小于<code>400px</code>，在这种情况下侧边栏变成<code>100px</code>宽。</p>
<p>问题当然是：我们测量的宽度是多少?</p>
<p>有两个相关的媒体查询:``width/height<code>和</code>device-width/device-height`。</p>
<ol>
<li><code>width/height</code> 使用与<code>documentElement.clientwidth /Height</code>（换句话说，<code>viewport</code>）。它适用于<code>CSS</code>像素。</li>
<li><code>device-width/device-height</code> 使用与<code>screen.width/height</code>相同的值。(换句话说，屏幕)。它适用于设备像素。</li>
</ol>
<p><img src="https://www.quirksmode.org/mobile/pix/viewport/desktop_mediaqueries.jpg" alt="img"></p>
<p>你应该使用哪一种？显而易见，<code>width</code>。Web开发人员对设备宽度不感兴趣；重要的是浏览器窗口的宽度。</p>
<p>所以在桌面使用宽度，而忘记设备宽度。我们将看到，移动平台的情况更加混乱。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>这就是我们对桌面浏览器行为的探索。本系列的第二部分将这些概念移植到移动设备，并强调了与桌面设备的一些重要区别。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/19/this%E6%98%AF%E4%BB%80%E4%B9%88/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/19/this%E6%98%AF%E4%BB%80%E4%B9%88/" class="post-title-link" itemprop="url">this是什么</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-19 21:14:26" itemprop="dateCreated datePublished" datetime="2021-09-19T21:14:26+08:00">2021-09-19</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="this是什么？"><a href="#this是什么？" class="headerlink" title="this是什么？"></a>this是什么？</h1><p>this是函数内部的一个对象，引用的是把函数当成<strong>方法</strong>的<strong>上下文</strong>对象。</p>
<ul>
<li><p>在标准函数中，this引用的是把函数当成方法<strong>调用</strong>的上下文对象。</p>
</li>
<li><p>在箭头函数中，this引用的是<strong>定义</strong>箭头函数的上下文。</p>
</li>
</ul>
<p>那么上下文对象是什么呢？</p>
<p>上下文是<strong>执行</strong>上下文的简称，主要有全局上下文和局部上下文两种，每个函数调用都有自己的上下文。变量或函数的上下文决定了它们可以访问哪些数据，以及他们的行为。每个上下文都有一个关联的<strong>变量对象</strong>，而这个上下文中定义的所有变量和函数都存在于这个对象上。</p>
<p>我的理解呢就是，作用域链的数据结构类似于栈，每个函数都有自己的作用域链，<strong>定义</strong>时初始化，预装载全局变量。函数<strong>调用</strong>时，创建执行上下文，更新作用域链。</p>
<p>先来看一下标准函数，我们常写的是下面这种方式，A是全局上下文中的对象，<code>sayHello</code>是作为A的方法调用的，因此<code>this</code>引用的是A：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.sayHello() <span class="comment">// A</span></span><br></pre></td></tr></table></figure>

<p>那么如果在A中执行呢？因为A定义是在全局作用域中，所以其实和直接在全局执行一样，立即执行函数的this引用的是Window：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// Window</span></span><br><span class="line">    &#125;)()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>

<p>这样就不难理解箭头函数中this的引用了：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">       <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.sayHello() <span class="comment">// Cannot read property &#x27;name&#x27; of undefined</span></span><br></pre></td></tr></table></figure>

<p>在标准函数中this和arguments是在被调用时创建的，在闭包中使用this时，内部函数永远不可能直接访问外部函数的this和arguments变量：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.sayHello()() <span class="comment">// Window</span></span><br></pre></td></tr></table></figure>

<p>可以通过把this保存到闭包可以访问的另一个变量来解决这个问题。下面的例子中，箭头函数是在标准函数中定义并返回的，this引用的是<code>A.sayHello</code>的上下文:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>.name)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.sayHello()() <span class="comment">// A</span></span><br></pre></td></tr></table></figure>

<p>在函数定义阶段呢，就是Window：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> A = &#123;</span><br><span class="line">    <span class="attr">name</span>: <span class="string">&#x27;A&#x27;</span>,</span><br><span class="line">    <span class="attr">sayHello</span>: (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        (<span class="function">() =&gt;</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// Window</span></span><br><span class="line">        &#125;)()</span><br><span class="line">    &#125;)()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E5%85%AD%E3%80%81%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E5%85%AD%E3%80%81%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/" class="post-title-link" itemprop="url">webpack入门六、性能调优</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 22:40:22" itemprop="dateCreated datePublished" datetime="2021-09-10T22:40:22+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="webpack性能调优"><a href="#webpack性能调优" class="headerlink" title="webpack性能调优"></a><code>webpack</code>性能调优</h1><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul>
<li>打包结果优化</li>
<li>构建过程优化</li>
<li>tree-shaking</li>
</ul>
<p><code>webpack</code>在生产环境下会自动压缩代码</p>
<h4 id="预制terser-plugin：实现插件定制"><a href="#预制terser-plugin：实现插件定制" class="headerlink" title="预制terser plugin：实现插件定制"></a>预制<code>terser plugin</code>：实现插件定制</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> TerserPlugin = <span class="built_in">require</span>(<span class="string">&#x27;terser-webpack-plugin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">optimization: &#123;</span><br><span class="line">       <span class="attr">minimizer</span>: [<span class="keyword">new</span> TerserPlugin(&#123;</span><br><span class="line">           <span class="comment">// 使用缓存，加快构建速度</span></span><br><span class="line">           <span class="attr">cache</span>: <span class="literal">true</span>,</span><br><span class="line">           <span class="attr">parallel</span>: <span class="literal">true</span>,</span><br><span class="line">           <span class="comment">// 打包多线程</span></span><br><span class="line">           <span class="attr">TerserOptions</span>: &#123;</span><br><span class="line">               <span class="attr">compress</span>: &#123;</span><br><span class="line">                   <span class="comment">// 移除无用代码,debugger、console等</span></span><br><span class="line">                   <span class="attr">unused</span>: <span class="literal">true</span>,</span><br><span class="line">                   <span class="attr">drop_debugger</span>: <span class="literal">true</span>,</span><br><span class="line">                   <span class="attr">drop_console</span>: <span class="literal">true</span>,</span><br><span class="line">                   <span class="attr">dead_code</span>: <span class="literal">true</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;)]</span><br><span class="line">   &#125;,</span><br></pre></td></tr></table></figure>

<p>打包结果可视化分析：<code>webpack.bundle-analyzer</code>，可以看到哪一部分占的体积更大</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack-bundle-analyzer</span><br></pre></td></tr></table></figure>

<p>配置：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> BundleAnalyzerPlugin()</span><br></pre></td></tr></table></figure>

<p>报错</p>
<blockquote>
<p>[webpack-cli] TypeError: BundleAnalyzerPlugin is not a constructor</p>
</blockquote>
<p>解决：解构赋值引用</p>
<h4 id="其他调优方式："><a href="#其他调优方式：" class="headerlink" title="其他调优方式："></a>其他调优方式：</h4><ul>
<li>减少解析：配置不解析的文件：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">noParse: /node_modules\/(jquery\.js)/,</span><br></pre></td></tr></table></figure>

<ul>
<li>减少查找：include只打包某些文件</li>
</ul>
<ul>
<li>利用多线程提高构建速度，并发执行子进程：</li>
</ul>
<ol>
<li><code>thread-loader</code>把loader放在worker线程池里，必须放在所有<code>loader</code>之前</li>
<li><code>HappyPack</code>：多进程</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 根据cpu数量创建线程池</span></span><br><span class="line"><span class="keyword">const</span> happyThreadPool = HappyPack.ThreadPool(&#123;<span class="attr">size</span>: os.cpus().length&#125;)</span><br><span class="line"><span class="comment">// url-loader file-loader不支持happypack</span></span><br></pre></td></tr></table></figure>

<ul>
<li><p>预编译：</p>
</li>
<li><p>缓存：fast-sass-loader并行处理sass文件</p>
</li>
</ul>
<ul>
<li>source-map</li>
</ul>
<h4 id="tree-shaking"><a href="#tree-shaking" class="headerlink" title="tree-shaking"></a>tree-shaking</h4><p>消除无用JavaScript代码<code>DCE</code>， 例如：引用未执行的模块</p>
<p>development：去掉无用引用</p>
<p>run build：直接去掉</p>
<p>总结：<code>webpack</code>是什么</p>
<ul>
<li><p>前端发展的产物</p>
</li>
<li><p>模块化打包方案</p>
</li>
<li><p>工程化方案 ，例如<code>create-react-app</code>也是基于<code>webpack</code></p>
</li>
</ul>
<p>补充：了解进程与线程的概念，<code>webpack</code>优化是体现工作能力的地方</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E4%BA%94%E3%80%81webpack%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E4%BA%94%E3%80%81webpack%E6%9E%84%E5%BB%BA%E5%B7%A5%E7%A8%8B/" class="post-title-link" itemprop="url">webpack入门五、webpack构建工程</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 22:05:39" itemprop="dateCreated datePublished" datetime="2021-09-10T22:05:39+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="webpack构建工程"><a href="#webpack构建工程" class="headerlink" title="webpack构建工程"></a><code>webpack</code>构建工程</h1><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul>
<li>使用<code>webpack</code>构建真实<code>react</code>工程</li>
<li>掌握<code>babel</code>的用法，理解<code>babel</code>原理</li>
<li>掌握高频<code>loader</code>和<code>plugin</code>的用法</li>
<li>掌握生产级别的<code>webpack</code>配置方法</li>
</ul>
<h4 id="准备工作："><a href="#准备工作：" class="headerlink" title="准备工作："></a>准备工作：</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mkdir learn<span class="literal">-webpack</span></span><br><span class="line"><span class="built_in">cd</span> learn<span class="literal">-webpack</span></span><br><span class="line">npm init</span><br><span class="line">npm init <span class="literal">-y</span> // 把所有预置项设置为npm默认</span><br><span class="line"><span class="built_in">ls</span></span><br><span class="line">npm install react react<span class="literal">-dom</span></span><br><span class="line">npm install webpack webpack<span class="literal">-cli</span> <span class="literal">-d</span></span><br></pre></td></tr></table></figure>

<h4 id="项目文件："><a href="#项目文件：" class="headerlink" title="项目文件："></a>项目文件：</h4><p><code>App.jsx</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"><span class="keyword">import</span> ReactDom <span class="keyword">from</span> <span class="string">&#x27;react-dom&#x27;</span></span><br><span class="line"><span class="keyword">import</span> &#123; isNull, isZero &#125; <span class="keyword">from</span> <span class="string">&#x27;./utils&#x27;</span></span><br><span class="line"></span><br><span class="line">isNull(&#123;&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> App = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">h1</span>&gt;</span>webpack学习<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> App</span><br><span class="line">ReactDom.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span>/&gt;</span></span>, <span class="built_in">document</span>.getElementById(<span class="string">&#x27;app&#x27;</span>))</span><br></pre></td></tr></table></figure>

<p><code>index.html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Webpack测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>webpack</code>读不懂<code>ES6</code>语法，也无法处理<code>html</code>文件。</p>
<h4 id="babel："><a href="#babel：" class="headerlink" title="babel："></a>babel：</h4><p>把高版本代码编译成低版本代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install @babel/core @babel/cli -g</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">babel test.js --presets=@babel/preset-env</span><br></pre></td></tr></table></figure>

<p><code>--presets=@babel/preset-env</code>是配置参数，指定转换规则。<code>presets-env</code>可以把高版本代码转换为低版本。写在配置文件中：</p>
<p><code>package.json</code>或者<code>.babelrc</code>文件(优先查询)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;babel&quot;</span>: &#123;</span><br><span class="line">	<span class="string">&quot;presets&quot;</span>: [<span class="string">&quot;@babel/presets-env&quot;</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="在webpack中使用babel"><a href="#在webpack中使用babel" class="headerlink" title="在webpack中使用babel"></a>在<code>webpack</code>中使用<code>babel</code></h4><p><code>webpack.config.js</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">module</span>: &#123;</span><br><span class="line">        <span class="attr">rules</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="attr">test</span>: <span class="regexp">/\.jsx?/</span>,</span><br><span class="line">                exclude: <span class="regexp">/node_modules/</span>, <span class="comment">// 不对node_module进行编译</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>安装loader和规则：解决代码转译问题：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install babel-loader</span><br><span class="line">npm install @babel/preset-env @babel/preset-react</span><br></pre></td></tr></table></figure>

<p>填写规则：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">options: &#123;</span><br><span class="line">    <span class="attr">babelrc</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">presets</span>: [</span><br><span class="line">        <span class="built_in">require</span>.resolve(<span class="string">&#x27;@babel/preset-react&#x27;</span>),</span><br><span class="line">        <span class="comment">// 转义jsx</span></span><br><span class="line">        [<span class="built_in">require</span>.resolve(<span class="string">&#x27;@babel/preset-env&#x27;</span>, &#123;<span class="attr">modules</span>: <span class="literal">false</span>&#125;)]</span><br><span class="line">        <span class="comment">// 转义ES6，webpack可以识别import语法</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">cacheDirectory</span>: <span class="literal">true</span>, <span class="comment">// 是否对转译结果做缓存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="html文件处理：plugin"><a href="#html文件处理：plugin" class="headerlink" title="html文件处理：plugin"></a><code>html</code>文件处理：<code>plugin</code></h4><p><code>plugin</code>实现节点层面的处理，以构造函数的形式存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install html-webpack-plugin -d</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">plugins: [</span><br><span class="line">        <span class="keyword">new</span> HtmlWebPackPlugin(&#123;</span><br><span class="line">            <span class="attr">template</span>: path.join(__dirname, <span class="string">&#x27;src/index.html&#x27;</span>),</span><br><span class="line">            <span class="comment">// 需要被处理的文件的路径</span></span><br><span class="line">            <span class="attr">filename</span>: <span class="string">&#x27;index.html&#x27;</span></span><br><span class="line">        &#125;)</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<p>入口文件<code>index.jsx</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">import App from &#x27;./App&#x27;</span><br></pre></td></tr></table></figure>

<p>import省略文件后缀：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line">       <span class="attr">extensions</span>: [<span class="string">&#x27;.wasm&#x27;</span>, <span class="string">&#x27;.mjs&#x27;</span>, <span class="string">&#x27;.js&#x27;</span>, <span class="string">&#x27;.jsx&#x27;</span>, <span class="string">&#x27;json&#x27;</span>]</span><br><span class="line">&#125;,</span><br><span class="line">    <span class="attr">entry</span>: path.resolve(__dirname, <span class="string">&#x27;src/index.jsx&#x27;</span>), <span class="comment">// 入口文件</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>ERROR in ./src/index.html 1:0<br>Module parse failed: Unexpected token (1:0)<br>You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See <a target="_blank" rel="noopener" href="https://webpack.js.org/concepts#loaders">https://webpack.js.org/concepts#loaders</a></p>
<blockquote>
<!DOCTYPE html>
<p>| <html lang="en"><br>| <head></p>
</blockquote>
<p>webpack 5.52.0 compiled with 1 error in 93 ms</p>
</blockquote>
<p>babel与babel-loader版本应该相匹配<a target="_blank" rel="noopener" href="https://www.npmjs.com/package/babel-loader">https://www.npmjs.com/package/babel-loader</a></p>
<h4 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h4><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">webpack<span class="literal">-dev</span><span class="literal">-server</span> -<span class="literal">-config</span> // 指定读取的config文件,比如webpack.config.dev.js</span><br><span class="line">webpack<span class="literal">-dev</span><span class="literal">-server</span> -<span class="literal">-open</span> // 打开浏览器</span><br></pre></td></tr></table></figure>

<p>自定义命令：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">    <span class="string">&quot;build&quot;</span>: <span class="string">&quot;webpack --mode production&quot;</span>, <span class="comment">// 打包</span></span><br><span class="line">    <span class="string">&quot;start&quot;</span>: <span class="string">&quot;webpack-dev-server --mode development --open&quot;</span> <span class="comment">// 预览</span></span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><code>HMR</code>热更新（热替换）， 在不刷新页面的情况下更新修改部分：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">	<span class="attr">hot</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="attr">Plugins</span>: [</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">new</span> webpack.HotModuleReplacementPlugin()</span><br><span class="line">    ...</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p><code>index.jsx</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="built_in">module</span>.hot) &#123;</span><br><span class="line">    <span class="built_in">module</span>.hot.accept(<span class="function"><span class="params">error</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(error) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;热替换出错&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E5%9B%9B%E3%80%81webpack%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E5%9B%9B%E3%80%81webpack%E6%A0%B8%E5%BF%83%E7%89%B9%E6%80%A7/" class="post-title-link" itemprop="url">webpack入门四、webpack核心特性</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 21:28:46" itemprop="dateCreated datePublished" datetime="2021-09-10T21:28:46+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="webpack核心特性"><a href="#webpack核心特性" class="headerlink" title="webpack核心特性"></a>webpack核心特性</h1><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul>
<li>使用webpack构建简单工程</li>
<li>了解webpack配置文件</li>
<li>掌握“一切皆模块与loaders”的思想</li>
<li>理解webpack中的“关键人物”—入口文件、出口文件、loaders、plugins</li>
</ul>
<p><code>index.html</code></p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">&quot;en&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">&quot;X-UA-Compatible&quot;</span> <span class="attr">content</span>=<span class="string">&quot;IE=edge&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;viewport&quot;</span> <span class="attr">content</span>=<span class="string">&quot;width=device-width, initial-scale=1.0&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>React Webpack测试<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">src</span>=<span class="string">&#x27;/dist/bunle.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p><code>moduleLog.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">document</span>.write(<span class="string">&#x27;moduleLog is loaded&#x27;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>src/index.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moduleLog <span class="keyword">from</span> <span class="string">&#x27;../moduleLog&#x27;</span></span><br><span class="line"><span class="built_in">document</span>.write(<span class="string">&#x27;入口js is loaded&#x27;</span>);</span><br><span class="line">moduleLog();</span><br></pre></td></tr></table></figure>

<h4 id="安装webpack和webpack-cli"><a href="#安装webpack和webpack-cli" class="headerlink" title="安装webpack和webpack-cli:"></a>安装webpack和webpack-cli:</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install webpack</span><br><span class="line">npm install webpack-cli -g</span><br></pre></td></tr></table></figure>

<blockquote>
<p>报错：无法将“WEBPACK”项识别为 CMDLET、函数、脚本文件或可运行程序的名称</p>
</blockquote>
<p>出现这个错误的原因是：windows10中，你的webpack是局部安装的，并没有加入到系统环境变量中，所以控制台找不到webpack命令，有以下方法可以解决：</p>
<ul>
<li>找到项目根目录下的<strong>package.json</strong>文件，配置<code>&#39;scripts&#39;</code>这个选项，配置加上<code>&quot;build&quot;：&quot;webpack&quot;</code>，然后运行<code>npm run build</code></li>
<li>全局安装webpack</li>
</ul>
<p>默认入口文件：src/index.js </p>
<p>出口：dist/main.js</p>
<h4 id="自定义配置文件："><a href="#自定义配置文件：" class="headerlink" title="自定义配置文件："></a>自定义配置文件：</h4><p><code>webpack.config.js</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">&#x27;path&#x27;</span>);</span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">    <span class="attr">entry</span>: <span class="string">&#x27;./app.js&#x27;</span>, <span class="comment">// 修改入口文件</span></span><br><span class="line">    <span class="attr">output</span>: &#123;</span><br><span class="line">        <span class="attr">path</span>: path.join(__dirname, <span class="string">&#x27;dist&#x27;</span>),</span><br><span class="line">        <span class="attr">filename</span>: <span class="string">&#x27;bundle.js&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>警告：WARNING in configuration<br>The ‘mode’ option has not been set, webpack will fallback to ‘production’<br>for this value.<br>Set ‘mode’ option to ‘development’ or ‘production’ to enable defaults for<br>each environment.</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mode: &#x27;development&#x27;</span><br></pre></td></tr></table></figure>

<p>但是每次修改都要保存、打包很麻烦，有没有自动的方法呢？</p>
<h4 id="自动打包工具：webpack-dev-server"><a href="#自动打包工具：webpack-dev-server" class="headerlink" title="自动打包工具：webpack-dev-server"></a>自动打包工具：webpack-dev-server</h4><p>启动<code>webpack-dev-server</code>可以监听工程目录文件的改动，修改源文件并再次保存可以实现动态实时打包，自动刷新浏览器。</p>
<p>不管cli还是webpack-dev-server都是可执行文件，一种方法是全局安装，或者进入node_module/.bin/server执行</p>
<blockquote>
<p>报错：.\webpack-dev-server : 无法加载文件 C:\Users\hh\github\learnwebpack\node_<br>modules.bin\webpack-dev-server.ps1，因为在此系统上禁止运行脚本。有关详细<br>信息，请参阅 https:/go.microsoft.com/fwlink/?LinkID=135170 中的 about_Exe<br>cution_Policies。</p>
</blockquote>
<ol>
<li>以管理员身份运行powershell</li>
<li>输入set-executionpolicy remotesigned，回车</li>
<li>输入yes</li>
</ol>
<p>指定本地服务端口：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">devServer: &#123;</span><br><span class="line">	<span class="attr">port</span>: <span class="number">3000</span>, <span class="comment">// 服务端口</span></span><br><span class="line">	<span class="attr">publicPath</span>: <span class="string">&#x27;/dist&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此时删除bundle.js依然可以运行，说明只在内存中生成了一个bundle.js，当浏览器发出请求时才会运行。</p>
<p>所有资源（图片、css等）都是模块</p>
<h4 id="文件编译：loader"><a href="#文件编译：loader" class="headerlink" title="文件编译：loader"></a>文件编译：loader</h4><p>安装css loader和style loader</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install css<span class="literal">-loader</span> -<span class="literal">-save</span><span class="literal">-dev</span></span><br><span class="line">npm install style<span class="literal">-loader</span> -<span class="literal">-save</span><span class="literal">-dev</span></span><br></pre></td></tr></table></figure>

<p>loader本质上是文件加载器</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: [</span><br><span class="line">            <span class="string">&#x27;style-loader&#x27;</span>, <span class="comment">// 加载样式</span></span><br><span class="line">            <span class="string">&#x27;css-loader&#x27;</span> <span class="comment">// 编译css文件，注意配置顺序与加载顺序相反</span></span><br><span class="line">        ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="plugins："><a href="#plugins：" class="headerlink" title="plugins："></a>plugins：</h4><p>监听事件，改变文件打包输出结果，比如压缩资源体积，去掉代码中的注释。</p>
<p>举例：引入uglify之前的打包结果：<code>asset bundle.js 4.26 KiB [emitted] (name: main) </code></p>
<p>安装：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install uglifyjs-webpack-plugin --save-dev</span><br></pre></td></tr></table></figure>

<p>引入：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> UglifyJSPlugin = <span class="built_in">require</span>(<span class="string">&quot;uglifyjs-webpack-plugin&quot;</span>)</span><br><span class="line">...</span><br><span class="line"><span class="attr">Plugins</span>: [</span><br><span class="line">	<span class="keyword">new</span> UglifyJSPlugin()</span><br><span class="line">]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>asset bundle.js 1.82 KiB [emitted] (name: main)</code></p>
<p>代码体积减小了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-npm%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/10/webpack%E5%85%A5%E9%97%A8%E4%B8%89%E3%80%81%E9%85%8D%E7%BD%AE%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83-npm%E4%B8%8E%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/" class="post-title-link" itemprop="url">webpack入门三、配置开发环境-npm与包管理器</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 20:58:27" itemprop="dateCreated datePublished" datetime="2021-09-10T20:58:27+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h1 id="配置开发环境——npm与包管理器"><a href="#配置开发环境——npm与包管理器" class="headerlink" title="配置开发环境——npm与包管理器"></a>配置开发环境——<code>npm</code>与包管理器</h1><h4 id="学习目标"><a href="#学习目标" class="headerlink" title="学习目标"></a>学习目标</h4><ul>
<li>理解包管理器</li>
<li>熟悉<code>npm</code>核心特性</li>
<li>理解<code>npm</code>”仓库“与”依赖“的概念</li>
<li>理解<code>npm</code>”语义化版本“</li>
<li>掌握使用<code>npm</code>自定义工程脚本的方法</li>
</ul>
<h4 id="什么是包管理器？"><a href="#什么是包管理器？" class="headerlink" title="什么是包管理器？"></a>什么是包管理器？</h4><p>使开发者能够便捷的管理代码和分发代码的工具</p>
<h6 id="npm依赖node环境，安装node会自动安装npm，查看node版本和npm版本："><a href="#npm依赖node环境，安装node会自动安装npm，查看node版本和npm版本：" class="headerlink" title="npm依赖node环境，安装node会自动安装npm，查看node版本和npm版本："></a><code>npm</code>依赖<code>node</code>环境，安装<code>node</code>会自动安装<code>npm</code>，查看<code>node</code>版本和<code>npm</code>版本：</h6><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node -v // 查看node版本</span><br><span class="line">npm -v // 查看npm版本</span><br></pre></td></tr></table></figure>

<h6 id="初始化工程："><a href="#初始化工程：" class="headerlink" title="初始化工程："></a>初始化工程：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm-init </span><br></pre></td></tr></table></figure>

<h6 id="package-json："><a href="#package-json：" class="headerlink" title="package.json："></a><code>package.json</code>：</h6><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">&quot;name&quot;</span>: <span class="string">&quot;learn-webpack&quot;</span>, <span class="comment">// 包名称</span></span><br><span class="line">  <span class="attr">&quot;version&quot;</span>: <span class="string">&quot;1.0.0&quot;</span>, <span class="comment">// 版本号</span></span><br><span class="line">  <span class="attr">&quot;description&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;main&quot;</span>: <span class="string">&quot;index.js&quot;</span>, <span class="comment">// 执行入口</span></span><br><span class="line">  <span class="attr">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">    <span class="attr">&quot;test&quot;</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span>,</span><br><span class="line">  &#125;, <span class="comment">// 自定义脚本，自动化执行命令</span></span><br><span class="line">  <span class="attr">&quot;author&quot;</span>: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  <span class="attr">&quot;license&quot;</span>: <span class="string">&quot;ISC&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="设置国内镜像："><a href="#设置国内镜像：" class="headerlink" title="设置国内镜像："></a>设置国内镜像：</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h6 id="安装包："><a href="#安装包：" class="headerlink" title="安装包："></a>安装包：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install lodash --save</span><br></pre></td></tr></table></figure>

<p><code>--save</code>或<code> -s</code>将下载的包写入<code>package.json</code>的<em>生产环境</em>下的依赖<code>dependencies</code>中，<code>npm</code>5.0版本之后默认<code>--save</code></p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install jquary -<span class="literal">-save</span><span class="literal">-dev</span></span><br><span class="line"><span class="literal">-d</span></span><br></pre></td></tr></table></figure>

<p><code>--save-dev</code>或<code>-d</code>添加到<em>开发环境</em>下的依赖<code>devDepencies</code>，主要是构建工具，质量检测工具比如<code>eslint</code>等本地开发用到的包。</p>
<p>项目迁移时，执行<code>npm install</code>即可安装`开发环境和生产环境下的包。</p>
<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -<span class="literal">-only</span>=dev</span><br></pre></td></tr></table></figure>

<p>只安装开发环境下的包</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --only=prod</span><br></pre></td></tr></table></figure>

<p>只安装生产环境中的包，由此可以实现环境区分。</p>
<h6 id="删除并重装"><a href="#删除并重装" class="headerlink" title="删除并重装"></a>删除并重装</h6><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rm</span> <span class="literal">-rf</span> node_modules &amp;&amp; npm install</span><br></pre></td></tr></table></figure>

<h4 id="版本号，语义化版本"><a href="#版本号，语义化版本" class="headerlink" title="版本号，语义化版本"></a>版本号，语义化版本</h4><ul>
<li><p>^version: 中版本和小版本</p>
<p>^1.0.1 -&gt; 1.x.x</p>
</li>
<li><p>~version: 小版本</p>
<p>~1.0.1 -&gt; 1.0.x</p>
<p>方便推送小的新版本（fix bug等)</p>
</li>
<li><p>version：固定特定版本</p>
</li>
</ul>
<h4 id="scripts自定义命令执行脚本"><a href="#scripts自定义命令执行脚本" class="headerlink" title="scripts自定义命令执行脚本"></a>scripts自定义命令执行脚本</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;    </span><br><span class="line">    <span class="attr">test</span>: <span class="string">&quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;</span></span><br><span class="line">    <span class="attr">dev</span>: <span class="string">&quot;webpack-dev-sever&quot;</span><span class="comment">//启动ewbpack服务	</span></span><br><span class="line">    <span class="attr">build</span>: <span class="string">&#x27;eslint ./src &amp;&amp; webpack&#x27;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="npm-install的过程："><a href="#npm-install的过程：" class="headerlink" title="npm install的过程："></a><code>npm install</code>的过程：</h4><p><a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/s/5tmND0G_ZkYVR7Dmug0ugQ">https://mp.weixin.qq.com/s/5tmND0G_ZkYVR7Dmug0ugQ</a></p>
<ul>
<li>寻找包版本信息文件<code>package.json</code>，依照它来进行安装</li>
<li>查<code>package.json</code>中的依赖，并检查项目中其他版本信息文件，如果不存在，则按照<code>package.json</code>的依赖进行安装，并生成版本信息文件</li>
<li>如果发现了新包，就更新版本信息文件</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en">
    <link itemprop="mainEntityOfPage" href="https://hmt0.github.io/project/2021/09/10/for-of-%E4%B8%8E-for-in%E7%9A%84%E5%8C%BA%E5%88%AB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/project/images/avatar.gif">
      <meta itemprop="name" content="He Mengting">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="hmt的博客">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/project/2021/09/10/for-of-%E4%B8%8E-for-in%E7%9A%84%E5%8C%BA%E5%88%AB/" class="post-title-link" itemprop="url">for...of 与 for...in的区别</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">Posted on</span>

              <time title="Created: 2021-09-10 16:44:47" itemprop="dateCreated datePublished" datetime="2021-09-10T16:44:47+08:00">2021-09-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">Edited on</span>
                <time title="Modified: 2022-01-18 17:31:37" itemprop="dateModified" datetime="2022-01-18T17:31:37+08:00">2022-01-18</time>
              </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><code>for...of</code>和<code>for...in</code>的作用都是迭代。它们之间的主要区别是迭代的内容。</p>
<p><code>for...in</code>语句以任意顺序迭代<strong>对象</strong>的可枚举<strong>属性</strong>，包括实例属性和原型属性。</p>
<p><code>for...of</code>语句迭代<strong>可迭代对象</strong>定义的要迭代的<strong>值</strong>。</p>
<p>那么，可迭代对象有哪些呢？包括：<code>String</code>，<code>Array</code>，<code>array-like objects</code>，<code>TypedArray</code>，<code>Map</code>，<code>Set</code>。</p>
<p>注意Object实例不是可迭代对象，所以不能用<code>for...of</code>迭代它的值，但可以用<code>for...in</code>枚举它的属性。</p>
<p>下面的例子展示了<code>for...of</code>循环和<code>for...in</code>循环应用在数组上的区别：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;， &quot;arrCustom&quot;, &quot;objCustom&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">    <span class="keyword">if</span>(iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>让我们一步一步地看一下上面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.objCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">Array</span>.prototype.arrCustom = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> iterable = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line">iterable.foo = <span class="string">&#x27;hello&#x27;</span>;</span><br></pre></td></tr></table></figure>

<p>每个对象实例都会继承<code>objectCustom</code>属性，并且每个Array对象的实例都会继承<code>arrCustom</code>属性，这是因为这些属性已分别添加到<code>Onject.prototype</code>和<code>Array.prototype</code>。由于继承和原型链，可迭代对象继承了属性<code>objCustom</code>和<code>arrCustom</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, &quot;foo&quot;, &quot;arrCustom&quot;, &quot;objCustom&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环只以任意顺序打印了可迭代对象的枚举属性。它不会打印数组<strong>元素</strong><code>3</code>，<code>5</code>，<code>7</code>或者<code>hello</code>，因为它们不是可枚举属性，<strong>实际上它们根本不是属性</strong>，它们是值。它所打印的数组的下标，还有<code>arrCustom</code>和<code>objCustom</code>才是属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">in</span> iterable) &#123;</span><br><span class="line">  <span class="keyword">if</span> (iterable.hasOwnProperty(i)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i); <span class="comment">// logs 0, 1, 2, &quot;foo&quot;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环和上一个相似，但它使用<code>hasOwnProperty()</code>来检查可枚举属性是否是对象自身的，不是继承的。如果是，则打印该属性。属性<code>0</code>，<code>1</code>，<code>2</code>和<code>foo</code>被输出，因为他们是自有属性(不是继承的)。属性<code>arrCustom</code>和<code>objCustom</code>没有被输出，因为他们是继承的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> i <span class="keyword">of</span> iterable) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// logs 3, 5, 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个循环迭代并打印了可迭代的值，作为可迭代对象所定义的要迭代的值。对象的元素 3、5、7被打印，但没有打印对象的任何属性。</p>
<p>补充：JavaScript规范定义的数据属性[[Enumerable]]表示属性是否可以通过<code>for...in</code>循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/project/"><i class="fa fa-angle-left" aria-label="Previous page"></i></a><a class="page-number" href="/project/">1</a><span class="page-number current">2</span><a class="page-number" href="/project/page/3/">3</a><a class="extend next" rel="next" href="/project/page/3/"><i class="fa fa-angle-right" aria-label="Next page"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">He Mengting</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/project/archives/">
        
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">tags</span>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">He Mengting</span>
</div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/project/lib/anime.min.js"></script>
  <script src="/project/lib/velocity/velocity.min.js"></script>
  <script src="/project/lib/velocity/velocity.ui.min.js"></script>

<script src="/project/js/utils.js"></script>

<script src="/project/js/motion.js"></script>


<script src="/project/js/schemes/muse.js"></script>


<script src="/project/js/next-boot.js"></script>




  















  

  

</body>
</html>
